## 包

### 包的命名

包的命名规范：`com.公司名.项目名.业务模块名`

### 包说明

包管理风格有两种，一种是以 `.` 分割。一种采用 `{}` 嵌套

```scala
package a {
	package b {
		package c{
			// c 中的代码块
		}
	}
}
```

这种方式声明的包，里层和外层的内容可以互相访问，不需要导入

### 包对象

可以为每个包定义一个独一份的同名的包对象作为这个包下所有的`class`和`object`的共享变量，可以直接被访问

包对象创建默认是使用嵌套的形式

```scala
package object NAME {
	// 全局共享的属性和方法
}
```

### 导包

使用`import` 关键字导入

- `import java.util._` 通配符导入
- `import java.util.{ArrayList=>JL}` 导入类起别名
- `import java.util.{class, class, class}`  导入多个类
- `import javautil.{ArrayList=>_, _}` 屏蔽类 ArrayList
- `new 绝对路径`

scala默认导入三个包

```scala
import java.lang._
import scala._
import scala.Preder._
```

## 类和对象

类中的属性可以通过类型注解`@BeanProperty`快速生成`setter`和`getter`

```scala
package MIB  
  
import scala.beans.BeanProperty  
  
class Student() {  
  @BeanProperty   // 类型注解自动生成 setter  getter  
  var sno: String = _  
  var major: String = _  
}
```

## 封装

将抽象出的数据和对数据的操作封装在一起，只有通过部分授权的成员方法访问和修改

scala中没有`public`属性，所有没有指定的都是`public`，但是底层实际为`private`

scala中不推荐将属性设为`private`然后实现`getter、setter`，但是由于很多Java框架都会利用`getter、setter`这时一般通过类型注解`@BeanProperty`实现

### 访问权限

所有没有限制的皆为`public`，`private`仅限类内部与伴生对象使用，`protected`同类和子类可以访问，但是同包是不能访问的

`private[包名]`：给包添加访问权限，包名下的其他类可以访问此属性和方法

### 构造器

Scala类的构造器包括：主构造器和辅助构造器

```scala
class 类名(参数列表) {  // 主构造器
	def this(参数列表) {   // 辅助构造器   可以有多个
		this()    // 必须调用主构造器
	}
}
```

辅助构造器不能直接构建对象，必须直接或间接调用主构造方法，后声明的构造器可以调用先声明的构造器

```scala
class obb(a: Int, b: Int) {  
  var an: Int = a  
  var bn: Int = b  
}
```

构造器的参数可以使用`var、val`修饰
- 如果不修饰，代表这个参数就是一个局部变量（需要在类中定义变量赋值）
- `var`：作为类的成员属性，可以修改
- `val`：作为类的只读属性，不能修改

此时的参数依然可以使用访问修饰符修饰（默认`public`）

```scala
class obb(private val a: Int, var b: Int) {  
}
```

## 继承和多态

继承
```scala
class 子类 extend 父类 {
}
```

当多个子类中都重写了父类的方法，而在使用时，需要根据不同的类的实例对象，调用不同类中的相同的方法时，只需传入父类即可

动态绑定

对于上述的情况，需要在传参后才能确定是那个类 => 动态绑定

即将子类的实例对象，赋给父类的类型引用

```scala
def f(con: 父类) {
	con.方法()
}

f(子类实例对象)
```

java中动态绑定仅限于方法，scala中动态绑定不仅仅对于方法，属性也可以

## 抽象属性和抽象方法


## 单列对象

## 特质

Scala提供“特质（`trait`）”而非接口。特质可以同时拥有抽象方法和具体方法，以及状态

对于一个只是声明的类，那么他如果没有继承一个类，而是直接引入`trait`那么这个`trait`必须使用`extends`关键字，其他更多的`trait`必须在其之后，每一个都要使用`with`关键字

对于一个以及实例化的类，那么如果需要扩展，就需要使用`with`关键字指定`trait`

**在声明类的时候扩展trait**

```scala
trait Phone {  
  val phoneName: String  
  def Print(): Unit  // 抽象方法  
}  
  
class Jack extends Phone {    // 如果有多个需要在后面 with trait 的形式添加
  val personName: String = "Jack"  
  override val phoneName: String = "三星"  
  
  override def Print(): Unit = {  
    print(s"$personName 的 $phoneName 手机")  
  }  
}  
  
def main(args: Array[String]): Unit = {  
  val j = new Jack  
  j.Print()  
}
```

**在实例化对象时扩展**

```scala
trait Phone {  
  val phoneName: String  
  def Print(): Unit  // 抽象方法  
}  
  
class Jack{  
  val personName: String = "Jack"  
}  
  
def main(args: Array[String]): Unit = {  
  val j = new Jack with Phone {  
    override val phoneName: String = "三星"  
  
    override def Print(): Unit = print(s"$personName 的 $phoneName 手机")  
  }  
  j.Print()  
}
```

## 示例

创建两个特质

```scala
package test_01  
  
trait CarId {  
  var id: Int  
  def currentId(): Int   // 抽象方法  
  def sayHello(): Unit = {    // 具体实现  
    print(currentId())  
    println("你好，特质中可以包含方法的定义，也可以包含方法的实现")  
  }  
}

package test_01  
  
trait Flyer {  
  var id: Int  
  def fly(): Unit  
}
```

创建两个类扩展这些特质

```scala
package test_01  
  
class BMWCarId extends Flyer with CarId {  
  override var id: Int = 20000  
  
  override def currentId(): Int = {   // 实现抽象方法  
    id += 1  
    id  
  }  
  
  override def fly(): Unit = {  
    println("BWM实现 fly 方法")  
  }  
}


package test_01  
  
class BYDCarId extends CarId with Flyer {  
  override var id: Int = 10000  
  
  override def currentId(): Int = {  
    id += 1  
    id  
  }  
  
  override def fly(): Unit = {  
    println("BYD实现 fly 方法")  
  }  
}
```

像`class BMWCarId extends Flyer with CarId`会将`Flyer with CarId`堪为一个整体，先有`Flyer`扩展`CarId`，再将这个整体扩展到`BMWCarId`上

调用

```scala
package test_01  
  
object App {  
  
  def main(args:Array[String]): Unit = {  
  
    val car1 = new BYDCarId  
    val car2 = new BMWCarId  
    car1.sayHello()  
    car2.sayHello()  
    car1.fly()  
    car2.fly()  
  }  
}
```

输出

```txt
10001你好，特质中可以包含方法的定义，也可以包含方法的实现
20001你好，特质中可以包含方法的定义，也可以包含方法的实现
BYD实现 fly 方法
BWM实现 fly 方法
```


## 隐式转换方法

在不修改类的情况下，给类添加新的方法

