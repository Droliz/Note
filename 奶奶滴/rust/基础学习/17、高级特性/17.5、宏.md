## 宏

### 简介

**宏**（_Macro_）指的是 Rust 中一系列的功能：使用 `macro_rules!` 的 **声明**（_Declarative_）宏，和三种 **过程**（_Procedural_）宏：

-   自定义 `#[derive]` 宏在结构体和枚举上指定通过 `derive` 属性添加的代码
-   类属性（Attribute-like）宏定义可用于任意项的自定义属性
-   类函数宏看起来像函数不过作用于作为参数传递的 token

### 函数与宏的区别

- 宏是一种为写其他代码而写代码的方式，即所谓的 **元编程**（_metaprogramming_）
- 一个函数签名必须声明函数参数个数和类型，宏能够接收不同数量的参数
- 宏可以在编译器翻译代码前展开
- 实现宏不如实现函数的一面是宏定义要比函数定义更复杂
- 在一个文件里调用宏 **之前** 必须定义它，或将其引入作用域，而函数则可以在任何地方定义和调用

### 声明宏

Rust 最常用的宏形式是 **声明宏**（_declarative macros_），可以使用 `macro_rules!` 来定义宏

```rust
#[macro_export]
macro_rules! vec {
	// 这个表达式，先使用 $x:expr 匹配一个表达式，然后使用 $( $x:expr ),* 匹配多个表达式，最后使用 { ... } 匹配一个代码块
	( $( $x:expr ),* ) => {  
		{
			let mut temp_vec = Vec::new();  // 创建一个 Vec
			$(
				temp_vec.push($x);  // 每次匹配到一个表达式，就生成一个 push 语句
			)*
			temp_vec  // 返回 temp_vec
		}
	};
}
```

上述是一个 `vec!` 宏的简化版本

`#[macro_export]` 注解表明只要导入了定义这个宏的 crate，该宏就应该是可用的。如果没有该注解，这个宏不能被引入作用域。

接着使用 `macro_rules!` 和宏名称开始宏定义，且所定义的宏并 **不带** 感叹号。名字后跟大括号表示宏定义体，在该例中宏名称是 `vec`

`vec!` 宏的结构和 `match` 表达式的结构类似。此处有一个分支模式 `( $( $x:expr ),* )` ，后跟 `=>` 以及和模式相关的代码块。如果模式匹配，该相关代码块将被执行

**宏模式所匹配的是 Rust 代码结构**

表达式中，先使用 `$x:expr` 匹配一个表达式，并命名为**宏变量** `$x` ，后面的 `,` 代表捕获的代码可能会出现一个 `,` 在后面，`*` 代表有零到多个前面的匹配项出现

### 过程宏

第二种形式的宏被称为 **过程宏**（_procedural macros_），因为它们更像函数（一种过程类型）。

过程宏接收 Rust 代码作为输入，在这些代码上进行操作，然后产生另一些代码作为输出，而非像声明式宏那样匹配对应模式然后以另一部分代码替换当前代码

有三种类型的过程宏（自定义派生（derive），类属性和类函数）

