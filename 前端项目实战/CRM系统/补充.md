## @Scheduled注解

`@Scheduled()`注解以及cron表达式详解
### `@Scheduled`注解：任务自动化调度。

1. `@Scheduled(fixedDelay = 5000)`
延迟执行。任务在上个任务完成后达到设置的延时时间就执行。

此处，任务会在上个任务完成后经过5s再执行。

2. `@Scheduled(fixedRate = 5000)`
定时执行。任务间隔规定时间即执行。

此处，任务每隔五秒便会执行一次。

3. `@Scheduled(cron = “0 0 2 * * ?”)`
自定义规则执行。比较复杂，一般用6或7个标识符(非官方叫法，方便区分记忆这么叫的)表示任务的执行规则。

此处的逻辑是每天的凌晨两点开始定时执行任务。

### 补充：cron表达式

例1：`@scheduled (cron="0 0 2 2 * ? *")` 表示：每月二号凌晨两点执行。

例2：`@scheduled (cron="15,20,40 15-20 2/5 L * ?")` 表示：每月的最后一天的凌晨2点开始每隔5小时的第15分钟到第20分钟之间的每分钟的第15,20,40秒执行一次。

例3：`@scheduled (cron="0 0 0 15W * ?")` 表示：每月离15号最近的工作日。

例4：`@scheduled (cron= "0 0 0 0 * 2#3 ")` 表示：每月的第三个周一。

(1) 标识符

从左到右用空格隔开分别是：秒 分 时 日 月 周 年(可省略)

第一个位置：Seconds 秒：区间 0-59 秒，代表一分钟内的秒数。

第二个位置：Minutes 分：区间 0-59 分，代表一小时内的分钟数。

第三个位置：Hours 时：区间 0-23 时，代表一天中的小时数。

第四个位置：Day of month 日：区间 1-31 (?根据每月有多少天来)，代表一月中的多少号。

第五个位置：Month 月：区间 1-12 ，代表一年中的月份。

第六个位置：Day of week 周：区间 1-7或者英文星期的缩写，代表星期几。

（注意：1 对应周日 SUN , 7 对应周六 SAT ，如此循环）

第七个位置：Year 年：区间1970-2099，代表具体年份，但是一般不用，可以直接不写。(为什么到了2099年就停了？)

下面是网上找的表格，方便记忆

|域	|是否必填|	值以及范围|	通配符|
|:--|:--:|:--:|:--:|
|秒	|是	|0-59|	, - * /|
|分   |是|	0-59|	, - * /|
|时	|是|	0-23|	, - * /|
|日	|是|	1-31|	, - * ? / L W|
|月	|是|	1-12 或 JAN-DEC|	, - * /|
|周	|是|	1-7 或 SUN-SAT|	, - * ? / L #|
|年	|否|	1970-2099|	, - * /|

(2) 字符
描述：写在cron表达式的标识符位置用于表达特定意义的字符，如 例1 中的：$0,2,*,？$

阿拉伯数字：数值，出现在标识符位置的数字代表对应值，比如第一个2代表两点，第二个2代表二号

$*$ ：通配，语义相当于每… 比如第五个位置的 $*$就表示每月都会执行(相当于$1-12$)

$?$ ：忽略，语义相当于不管… 比如第六个位置的?就表示不管当前是周几就会执行。至于为什么会有这种用法，我觉得应该是因为它和其他的字符可能会冲突。如果用 $*$ 的话表示周一到周日都会执行，此时其他语义就不明确了，所以如果用不上星期的话一般给它用一个$?$表示 not care。

$/$ ：间隔，语义相当于每隔… 比如例2中的第三个位置的2/5就表示从2点开始每隔五小时

$-$ ：区间，语义相当于第…到…的每… 比如例2中的第二个位置的15-20就表示第15分钟到20分钟之间的每分钟

$,$ ：枚举，语义相当于第…和… 比如例2中的第一个位置的15,20,40就表示第15秒、20秒和40秒

$L$ ：最后(last)，语义相当于最后一个 比如例2中的第四个位置的L就表示最后一天（2.18版本无法使用）

$W$ ：工作日，字面意思，就是工作日 比如例3中的第四个位置的15W表示15号附近最近的工作日，如果15号刚好是工作日那就15号触发，如果15号是周六那就14号触发，如果15号是周日那就16号触发。前面不带数字就是所有匹配的工作日。

$#$ ：周定位，语义相当于每月的第几个周几 比如例4中的第六个位置的2#3就表示第三个周一。


## @Transactional注解

@Transactional是spring中声明式事务管理的注解配置方式，相信这个注解的作用大家都很清楚。@Transactional注解可以帮助我们把事务开启、提交或者回滚的操作，通过aop的方式进行管理。通过@Transactional注解就能让spring为我们管理事务，免去了重复的事务管理逻辑，减少对业务代码的侵入，使我们开发人员能够专注于业务层面开发。

首先列出spring中的事务的传播特性的7个常量值：

|传播特性常量值|	说明|
|:--:|:--|
|PROPAGATION_REQUIRED|	如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择|
|PROPAGATION_SUPPORTS|	支持当前事务，如果当前没有事务，就以非事务方式执行|
|PROPAGATION_MANDATORY|	使用当前的事务，如果当前没有事务，就抛出异常|
|PROPAGATION_REQUIRES_NEW|	新建事务，如果当前存在事务，把当前事务挂起|
|PROPAGATION_NOT_SUPPORTED|	以非事务方式执行操作，如果当前存在事务，就把当前事务挂起|
|PROPAGATION_NEVER|	以非事务方式执行，如果当前存在事务，则抛出异常|
|PROPAGATION_NESTED|	如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作|

例如：

```java
@Transactional(propagation = Propagation.REQUIRED)
```

所谓事务传播性，就是被调用者的事务与调用者的事务之间的关系。举例说明：


```java
Class A {
    @Transactional(propagation=propagation.REQUIRED)
    public void aMethod {
        B b = new B();
        b.bMethod();
	}
}
 
//in B.java
Class B {
    @Transactional(propagation=propagation.REQUIRED)
    public void bMethod { 
	    //do  something 
    }
}
```
	
在上面这个例子中，传播性被设为了 `REQUIRED`，注意，这是默认值，也即不进行该参数配置等于配置成 `REQUIRED`。

`REQUIRED` 的含义是，支持当前已经存在的事务，如果还没有事务，就创建一个新事务。在上面这个例子中，假设调用 `aMethod` 前不存在任何事务，那么执行 `aMethod` 时会自动开启一个事务，而由 `aMethod` 调用 `bMethod` 时，由于事务已经存在，因此会使用已经存在的事务（也就是执行 `aMethod` 之前创建的那个事务,不会使用 `bMethod` 配置的事务）。

对于这样的配置，如果 `bMethod` 过程中发生异常需要回滚，那么aMethod中所进行的所有数据库操作也将同时被回滚，因为这两个方法使用了同一个事务，这样说应该很容易理解吧。

`SUPPORTS` 的含义是，支持当前事务，如果没有事务那么就不在事务中运行。`SUPPORTS` 传播性的逻辑含义比较模糊，因此一般是不推荐使用的。

`MANDATORY` 的含义是，支持当前已经存在的事务，如果还没有事务，就抛出一个异常。如果上例中 `aMethod` 的传播性配置为 `MANDATORY`，我们就无法在没有事务的情况下调用 `aMethod`，会抛出异常，因此，传播性为 `MANDATORY` 的方法必定是一个其他事务的子事务，当逻辑上独立存在没有意义或者可能违反数据、事务完整性的时候，就可以考虑设置这样的传播性设置。

`REQUIRES_NEW` 的含义是，挂起当前事务，创建一个新事务，new嘛，如果还没有事务，就简单地创建一个新事务，反正是要新建一个事务。

`NOT_SUPPORTED` 的含义是，强制不在事务中运行，如果当前存在一个事务，则挂起该事务，从英文意思上也容易理解，即不需要事务。

`NEVER` 的含义很简单，就是强制要求不在事务中运行，如果当前存在一个事务，则抛出异常，因此如果bMethod传播性是NEVER，则一定抛出异常，从不需要事务。

`NESTED` 的含义是，在当前事务中创建一个嵌套事务，如果还没有事务，那么就简单地创建一个新事务。


